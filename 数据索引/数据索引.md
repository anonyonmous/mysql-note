## 数据索引

### 索引类型

#### 聚集索引 

聚集索引就是将数据和索引都放到一起的一种索引结构。聚集索引的B+Tree上既有索引，又由数据，索引的逻辑顺序直接决定了数据的物理存储顺序。常见的primary key就是聚集索引。聚集索引的叶子节点存放的是表中所有行数据的记录信息。在innodb存储引擎中，如果没有显式的指定primary key，就会选着第一个不包含null的unique key 作为主键索引。如果没有unique key，就生成一个6字节的rowid作为主键。

#### 普通索引

普通索引是将数据和索引分开的一种索引结构。B+Tree的叶子节点上存放的是数据存放的物理地址。在检索时，需要先找到叶子节点的主键，在根据主键查找行数据。普通索引中会包含主键索引的值，如：给表中的name创建索引，其实是（id,name）这样的索引结构

#### 主键索引

主键索引其实就是聚集索引。在innodb引擎中，每个表都必须要有一个主键索引，可以由表中的一个或者多个字段组成。

主键索引必须满足以下条件：

1. 主键值必须全局唯一
2. 不能包含null值
3. 最好用自增列所为主键，可以保证数据插入的时候是顺序写。

#### 唯一索引

唯一索引是约束条件的一种，可以由单个或者多个列组成。在插入数据时，数据库会先判断当前数据是否已经存在。在大批量恢复导入数据的时候，可以先关闭唯一索引校验（`unique_checks` 属性控制），提高插入效率。

唯一索引和主键索引的区别在于唯一索引允许有null值，且一个表中可以有多个唯一索引。主键索引不允许有null值，且一个表中只能有一个。

#### 覆盖索引

只需要通过索引就可以查找到想要的数据，不需要回表查询，减少io次数的索引，成为覆盖索引。如：在表中有（id，name）两个字段，且name字段创建普通索引。因为在mysql中的普通索引会自带主键索引，当执行`select name from table where id = #{id}` 的时候，可以在B+Tree索引上找到结果数据，就不需要去磁盘查找。

> select * from table where id  = #{id} 不会使用到覆盖索引

#### 前缀索引

在varchar、text、blog等字符类型中，如果对整个字段添加索引，会导致数据量很大，这个时候就需要创建前缀索引。前缀索引是针对字符类型字段的前几个字符创建索引的一种方式。这样创建是索引更小，查找更快。

在order by 和group by中使用前缀索引，索引并不会生效。前缀索引也不会发生索引覆盖。

#### 哈希索引

哈希索引是利用hash算法，将键值对转换成哈希值，实现O(1)效率的查找。哈希索引只能实现等值查找，不能用来排序、模糊、范围查询等。

#### 联合索引

对表中的多个字段添加普通索引的方式，成为联合索引。联合索引的查询必须满足“左前缀“原则

###  索引优化

#### 索引下推

通过 `SHOW VARIABLES like '%optimizer_switch%'` 可以查看是否开启索引下推（默认是开启的）。在原先的mysql中，使用where条件查询会先将数据从innodb引擎层将数据全部查询出来，将数据交给server层，取出满足where条件的数据。如果开启的索引下推，在innodb引擎层面，就会根据where后面的索引条件将数据过滤，这样就减少了server层的计算压力。

#### 多范围读

Multi-Range Read是mysql5.6之后新增的特性。在没有MRR之前，mysql查询先根据where之后的普通索引查找到符合条件数据的主键索引，在根据主键索引去查找数据。由于主键索引和普通索引的存储顺序并不一定是一致的，就会产生磁盘的随机io

MRR先根据where之后的普通索引查询出满足条件的数据主键集合，将这些主键存入`read_rnd_buffer`中，然后对主键排序。通过参数`read_rnd_buffer_size` 来控制缓冲内存的大小

#### 索引失效情况

1. 通过索引扫码，满足条件的数据超过全表的30%，索引优化器就会自动选择全表扫描。

   > 可以通过 select * from table force index （index_name）where 强制使用索引

2. 联合索引中不满足最左原则
3. 在联合索引中，第一个索引使用的是范围查询（> = < between and）
4. 模糊查询中%在字符前面
5. 两个单列索引中，一个用于查询，一个用于排序，这样的情况只会用到一个索引。如果想用两个索引，则考虑使用联合索引
6. 在索引上使用了函数运算

#### explain

通过explain可以查看sql的执行计划，查看的结果是估算的，不能显示索引优化器所作的优化工作。

参数释义

- id：选择标识符
- select_type：查询的类型
- table：输出结果集的表
- partitions：匹配的分区
- type：表的连接类型
- possible_keys：查询时可能用到的索引
- key：实际使用的索引
- key_len：索引字段的长度
- ref：列与索引的比较
- rows：估算需要扫描的行数
- filtered：按表条件过滤的百分比
- extra：执行情况的描述和说明

##### id

每个sql的查询序号。id相同，执行顺序从上到小；id不同，值越大，优先级越高

##### select_type

每个select语句的类型

1. SIMPLE：简单查询
2. PRIMARY：子查询中最外层的查询
3. UNION：union中第二个或者后面的select语句
4. DEPENDENT UNION：union中第二个或后面的select语句
5. UNION RESULT：union查询的结果
6. SUBQUERY：子查询，结果不依赖于外部查询
7. DEPENDENT  SUNQUERY：子查询，结果依赖于外部查询
8. DERIVED：衍生表的子查询
9. UNCACHEABLE SUNQUERY：子结果的查询不能被缓存

##### table

显示要查询的数据库中表的名称

##### type

查询类型

1. system：查询表只有一行数据
2. const：查询优化器对sql进行优化，并转化为一个常量
3. eq_ref：使用唯一索引，对每个索引表中只有一条记录匹配。表中使用primary key 或者unique key作为连表条件
4. ref：连接查询中有列或常量用于查找索引上的值
5. range：检索指定范围的行，使用一个索引来选择行
6. index：遍历索引树，全部扫描
7. all：全表扫描

##### possiable key

sql语句中可能用到的索引

##### key

sql中用到的key值，如果没有用到索引，则为null

##### kee_len

索引中使用的字节数。显示索引字段的最大可能长度，并非实际使用长度

##### ref

列与索引的比较

##### rows

估算出结果集行数，估算出满足所需记录读取的行数

##### extra

- using where：不用读取表中的数据，仅通过索引就可获取满足条件的数据（不用回表）
- using temporary：group bu或者order by 中使用临时表存储数据（通过调整sort_buffer大小解决）
- using filesort：order by操作中，排序的数据超过了sort buffer的大小，将数据在磁盘上排序
- using join buffer：join的时候没有用到索引，需要缓存池来存储中间结果

