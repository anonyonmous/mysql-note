### 事务机制

#### 事务日志

##### redo log

redo log是innodb引擎的事务日志。mysql为了提高数据写入的效率，引入了buffer poll概念，每次写入都先将数据写入到buffer pool中，在定期刷新到磁盘。如果在刷盘之前mysql宕机，就会导致数据的丢失。为了解决这一问题，mysql引入了binlog和redo log的概念。

在数据写入到buffer pool直接，先将数据写入到redo log，当事务提交时，调用系统的fsync操作redo log 刷盘。如果mysql宕机，重启时只需要读取redo log中的数据即可。因为数据的写入是先写日志，后写buffer pool，就不会导致数据的丢失。

buffer pool的刷新是随机io，redo log是顺序追加操作，是顺序io

buffer pool的刷盘是以page为单位，默认是16kb，每次写入都在整个page的写入。而redo log只需要将修改的部分写入到日志中。

##### undo log

undo log是inndob引擎的事务回滚日志。当事务对数据库进行修改时，innodb会生成对应的undo log，如果事务执行失败或者回滚，就可以利用undo log恢复到数据原来的样子。undo log属于逻辑日志，记录数据修改的内容。

#### 事务特性

- 原子性：在一个事务中，所有的sql要么全部执行成功，要么全部执行失败。
- 持久性：事务条件之后，数据会写入磁盘，无论任何原因，数据都不会丢失。
- 隔离性：每个事务执行的时候相互隔离，不会影响到其他事务。
- 一致性：事务执行前后的数据总量应该一致。

#### 事务语句

- 开启事务：Start Transaction
- 提交事务：Commit Transaction
- 回滚事务：Rollback Transaction

#### 隔离级别

查看当前数据库的事务隔离级别

> SHOW VARIABLES like '%isolation%'

##### 并发问题

###### 脏读

事务A读取到事务B未提交的数据

###### 不可重读

事务A中多次读取数据，期间有事务B更新数据并提交，导致事务A读取多次的结果不一致。不可重读和脏读的区别在于：不可重读读取的是事务提交之后的数据，脏读读取的是事务提交前的数据。

###### 幻读

事务A中多次读取数据，期间有事务B插入数据并提交，导致事务A读取多次的结果不一致。幻读和不可重读的区别在于：幻读读取的是事务插入的数据，数据行数有变化，不可重读读取的是事务更新的时间，数据行数没有变化

##### 隔离级别

- 读未提交（read-uncommitted）：在一个事务中，可以读取到其他事务中没有提交的数据。
- 读已提交（read-committed）：在一个事务中，可以读取到其他事务中已经提交的数据，可以避免脏读。
- 可重复读（repeatable-read）：在事务开始直到结束，看见的数据都是一致的。
- 序列化（serializable）：在每次读数据的时候都会加表级共享锁，在写数据的时候加表级排它锁。